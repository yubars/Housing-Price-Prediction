# -*- coding: utf-8 -*-
"""Step 8 Testing_User_Data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nh8qSu6pdESFzuLDsall1WyfBmVCyfy1

#Importing Packages
"""

import pandas as pd
import json
from joblib import load

import warnings
warnings.filterwarnings("ignore")


"""#Loading and Pre-processing Data"""

user_data_2 = pd.read_csv("../Test Data/demo_test_data.csv")

# User 108 and 113
user_id = 108

user_data = user_data_2.loc[user_data_2["id"] == user_id]
user_data

zip_average_price = {30047: 224924.8452,
                     30087: 190259.9042}

zip = int(user_data["zip"])
print(f"User {user_id} belongs to the zip {zip}, and the average price for that zip is {zip_average_price[zip]}")

user_id = int(user_data["id"])
user_data = user_data.iloc[:1, 1:]

user_id

user_data

lotSizqSqFt = user_data["lotSizeSquareFeet"].values

# Loading the Encoding Database to encode the categorical data into numbers

file_path = "../../Output/encodings_database.json"
file = open(file_path, "r")
encodings_database = json.load(file)

categorical_cols = ["city", "state", "street", "streetSuffix", "landUseDescription", "zoningDescription", "lotTopography", "architecturalStyle", "condition", "heating", "airConditioning",	"foundation", "fireplace"]
numerical_cols = ["zip", "latitude", "longitude", "lotSizeAcres",	"lotSizeSquareFeet",	"yearBuilt",	"totalStories",	"totalRooms",	"bedrooms",	"baths", "soldYear"]

def encode_state(state):
    '''
    This function returns the label of the code of the entered state.
    Args:
        state: str
        - accepts states in USA

    Returns:
        state_code: int
            - -1 for invalid
            - 0 to 50 for actual state codes
    '''
    state = state.lower()
    if state not in encodings_database["state"].keys():
        print("Please enter one of the states of USA!")
        state_code = -1
    else:
        print("State Encoded")
        state_code = encodings_database["state"][state]
    return state_code

# Check whether the state is valid or not
state_code = encode_state(list(user_data["state"])[0])
print(state_code)

def validate_numerical_data(num_col_val):
    '''
    This function validates whether the input numerical column actually has the numerical data
    Args:
        num_col_val: str
            - string with an integer e.g. '56'
    Returns:
        number_flag: bool
            - True if all the data are real numbers
            - False if the data is other than real number
    '''
    valid_number_flag = True
    try:
        float(num_col_val)
    except:
        valid_number_flag = False
        print("Please enter a valid number!")
    else:
        print("Numerical Data: Detected and Validated")

    return valid_number_flag

for j, col in enumerate(numerical_cols):
    valid_number_flag = validate_numerical_data(list(user_data[col])[0])
    print(list(user_data[col])[0])
    print(valid_number_flag)
    print("\n")

def validate_categorical_data(cat_col_val):
    '''
    This function validates whether the input categorical column actually has the categorical data
    Args:
        cat_col_val: str
            - actual string value
    Returns:
        valid_categorical_flag: bool
            - True if all the data are strings
            - False if the data is other than strings
    '''
    valid_categorical_flag = True
    try:
        float(cat_col_val)
    except:
        if bool(cat_col_val) is False:
            valid_categorical_flag = False
            return valid_categorical_flag
        print("Categorical Data: Detected and Validated!")
    else:
        print("You tried to enter numerical data in categorical column!")
        valid_categorical_flag = False

    return valid_categorical_flag

for j, col in enumerate(categorical_cols):
    valid_categorical_flag = validate_categorical_data(list(user_data[col])[0])
    print(list(user_data[col])[0])
    print(valid_categorical_flag)
    print("\n")

user_data

for i, name in enumerate(categorical_cols):
  user_data[name] = encodings_database[name][user_data[name].values[0].lower()]

user_data

# Loading the MinMaxScalar to normalize the categorical features

filename = "../../Output/minMaxScalar.joblib"
minMaxScalar = load(filename)

# MINMAX NORMALIZATION:

categorical_cols.remove("state")
categorical_data = user_data[categorical_cols]

user_data[categorical_cols] = minMaxScalar.transform(categorical_data)

#Encoding state separately, since we did not have all the 50 states in the data
user_data["state"] /= 49

user_data

# Now we have all numerical values but in string format, so we convert all the values to numeric
user_data = user_data.apply(pd.to_numeric, errors="coerce")

# Loading the StandardScalar to normalize the numerical features

filename = "../../Output/standardScalar.joblib"
standardScalar = load(filename)

numerical_data = user_data[numerical_cols]

user_data[numerical_cols] = standardScalar.transform(numerical_data)

user_data.shape

user_data

# Now the new test data is ready to feed into the Random Forest Regression Model
# rf_model = load("/content/drive/MyDrive/Software Engg Regression Analysis/[LATEST] Manish New Data/final_rf_model.joblib"
rf_model = load("../../Output/rf_model_95_86_randomState27.joblib")

pred = rf_model.predict(user_data.values)
pred = round(pred[0], 3)
print("Predicted Housing Price:", pred)

# Dividing the predicted housing price by lotSizeSquareFeet

predPerSqFt = round((pred/lotSizqSqFt)[0], 3)
print(f"House Price per SqFt: {predPerSqFt}")

amortization_table = pd.read_csv("../Amortization/demo_amortization_table.csv")

amortization_table.head()

user_amortization_data = amortization_table.loc[amortization_table["id"] == user_id]
user_amortization_data

user_amortization_data["Predicted House Price"] = pred

user_amortization_data.head()

user_amortization_data["Predicted Square Feet Price"] = predPerSqFt

user_amortization_data["Equity Value"] = user_amortization_data["Predicted House Price"] - user_amortization_data["Remaining Principal"]

user_amortization_data

# !pip install cryptography

# Encrypting the data to get the cipher text using Fernet Encryption

from cryptography.fernet import Fernet

# Message to encrypt
id = str(int(user_amortization_data["id"]))
house_price = str(float(user_amortization_data["Predicted House Price"]))
house_price_per_sqft = str(float(user_amortization_data["Predicted Square Feet Price"]))
equity_value = str(round(float(user_amortization_data["Equity Value"]), 3))

# Generating the Key
key = Fernet.generate_key()
fernet = Fernet(key)

print(f"Encryption Key: {key}\n")

# Encrpyting the messages
enc_id = fernet.encrypt(id.encode())
enc_house_price = fernet.encrypt(house_price.encode())
enc_equity_value = fernet.encrypt(equity_value.encode())
enc_house_price_per_sqft = fernet.encrypt(house_price_per_sqft.encode())

print("User ID: ", id)
print(f"Encrypted User ID: {enc_id}\n")

print("Predicted House Price: ", house_price)
print(f"Encrypted House Price: {enc_house_price}\n")

print("Predicted House Price Per Sqft: ", house_price_per_sqft)
print(f"Encrypted House Price Per Sqft:  {enc_house_price_per_sqft}\n")

print("Predicted Equity Value: ", equity_value)
print(f"Encrypted Equity Value: {enc_equity_value}\n")

print(f"User {user_id} belongs to the zip {zip}, and the average price for that zip is {zip_average_price[zip]}")

# Decrypting the messages
dec_id = fernet.decrypt(enc_id).decode()
dec_house_price = fernet.decrypt(enc_house_price).decode()
dec_equity_value = fernet.decrypt(enc_equity_value).decode()
dec_house_price_per_sqft = fernet.decrypt(enc_house_price_per_sqft).decode()

print(f"Decrypted User ID: {dec_id}\n")
print("Decrypted House Price: ", dec_house_price)
print("Decrypted House Price Per Sqft: ", dec_house_price_per_sqft)
print("Decrypted Equity Value: ", dec_equity_value)
